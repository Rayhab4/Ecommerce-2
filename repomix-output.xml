This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
config/connect -db.ts
package.json
src/auth.ts
src/cloudinaryConfig.ts
src/controllers/Authcontrollers.ts
src/controllers/CartItemcontroller.ts
src/controllers/Contactcontroller.ts
src/controllers/Ordercontroller.ts
src/controllers/Productcontroller.ts
src/controllers/Usercontroller.ts
src/index.ts
src/middlewares/Authmiddlewares.ts
src/Models/CartItemModel.ts
src/Models/ContactModel.ts
src/Models/OrderModel.ts
src/Models/ProductModel.ts
src/Models/UserModel.ts
src/package.json
src/Response.ts
src/Routes/AuthRoutes.ts
src/Routes/CartItemRoutes.ts
src/Routes/ContactRoutes.ts
src/Routes/OrderRoutes.ts
src/Routes/ProductRoutes.ts
src/Routes/UserRoutes.ts
src/swagger.ts
src/tsconfig.json
src/types.ts
src/types/express.d.ts
src/utils/auth.ts
src/utils/jwt.ts
src/utils/sendEmails.ts
ts-server/package.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
node_modules/
.env
</file>

<file path="config/connect -db.ts">
import mongoose from "mongoose";

export const connectDB = async (mongoUri: string) => {
  try {
    await mongoose.connect(mongoUri);
    console.log("MongoDB connected");
  } catch (err) {
    console.error("MongoDB coction error:", err);
    process.exit(1);
  }
};
</file>

<file path="src/auth.ts">
import { Request, Response, NextFunction } from "express";
const {logger} = require("./loggers")
const isApiKeyValid =require("./Models/apiKey")
async function checkApiKey(req: Request, res: Response, next: NextFunction ) {
const authHeader=req.headers["authorization"]
if (authHeader === undefined){
    return res.status(400).json ({message: 'API is missing'})
}
const apiKey =authHeader.substring(6)
let check
try{
    check=await isApiKeyValid({ apiKey})
}catch (e){
    logger.error(e)
    return res.sendStatus(500)
}
if (check ===undefined) return res.sendStatus(500)
    if (check=== false)return res.sendStatus(401)
        next()
}
module.exports=checkApiKey
</file>

<file path="src/cloudinaryConfig.ts">
import { v2 as cloudinary } from 'cloudinary';
import dotenv from 'dotenv';

dotenv.config();

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});
export default cloudinary;
</file>

<file path="src/controllers/Contactcontroller.ts">
import  Contact  from "../Models/ContactModel";
import { Request, Response } from "express";
import mailerSender from "../utils/sendEmails";
import dotenv from "dotenv";
dotenv.config();

export const createContact = async (req: Request, res: Response): Promise<void> => {
  try {
    const { name, email, phone, message } = req.body;

    if (!name || !email || !message) {
      res.status(400).json({ message: "Name, email and message are required." });
      return;
    }

    const newContact = new Contact({ name, email, phone, message });
    await newContact.save();

    const adminEmail = process.env.ADMIN_EMAIL;
    if (adminEmail) {
      const htmlContentAdmin = `
        <h3>New Contact Message</h3>
        <p><strong>Name:</strong> ${name}</p>
        <p><strong>Email:</strong> ${email}</p>
        <p><strong>Phone:</strong> ${phone || "N/A"}</p>
        <p><strong>Message:</strong> ${message}</p>
      `;

      await mailerSender(adminEmail, "New Contact Message Received", htmlContentAdmin);
    }


    const htmlContentUser = `
      <h3>Hello ${name},</h3>
      <p>Thank you for reaching out! We've received your message:</p>
      <p>"${message}"</p>
      <p>Our team will get back to you shortly.</p>
      <br/>
      <p>Best regards,</p>
      <p><strong>KLab Team</strong></p>
    `;

    await mailerSender(email, "Thank you for contacting us", htmlContentUser);

    res.status(201).json({
      message: "Contact message created successfully, confirmation email sent.",
      contact: newContact,
    });
  } catch (error: unknown) {
    const err = error as Error;
    console.error("Error creating contact:", err);
    res.status(500).json({ message: "Server Error", error: err.message });
  }
};
</file>

<file path="src/Models/ContactModel.ts">
import {Document,Schema,model} from "mongoose";
export interface IContact extends Document{
    name:String;
    email:String;
    phone:String;
    message:String;
}
const contactSchema=new Schema<IContact>({
    name: {type:String,required:true},
    email:{type:String,required:true},
    phone:{type:String,required:true},
    message:{type:String,required:true},
},
{
    timestamps: true,
}
);
export  default model<IContact>('Contact', contactSchema);
</file>

<file path="src/Models/ProductModel.ts">
import mongoose, { Schema, Document } from "mongoose";
export interface IProduct extends Document {
  name: string;
  description: string;
  price: number;
  imageUrl?: string;
  category?: string;
}

const productSchema: Schema<IProduct> = new Schema(
  {
    name: { type: String, required: true },
    description: { type: String, required: true },
    price: { type: Number, required: true },
    imageUrl: { type: String },
    category: { type: String },
  },
  { timestamps: true }
);

export default mongoose.model<IProduct>('Product', productSchema);
</file>

<file path="src/package.json">
{
  "name": "e-commerce",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/app.ts",
    "build": "tsc",
    "start": "node dist/app.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^7.0.0",
    "dotenv": "^17.2.2"
  },
  "devDependencies": {
    "typescript": "^5.2.0",
    "ts-node-dev": "^2.0.0",
    "@types/express": "^4.17.17",
    "@types/node": "^20.5.1"
  }
}
</file>

<file path="src/Response.ts">
import express,{ Response } from "express";

export const ok = (res: Response, data: any, msg?: string, code = 200) =>
  res.status(code).json({ success: true, data, message: msg });

export const fail = (res: Response, msg: string, code = 400) =>
  res.status(code).json({ success: false, data: null, message: msg });
</file>

<file path="src/Routes/ContactRoutes.ts">
import express from "express";
import { createContact } from "../controllers/Contactcontroller";

const router = express.Router();
router.post("/", createContact);

export default router;
</file>

<file path="src/Routes/UserRoutes.ts">
import express from 'express';
import { newuser, getUser, updateUser, deleteUser } from '../controllers/Usercontroller';
import { authMiddleware } from '../middlewares/Authmiddlewares';

const router = express.Router();

// Create a new user (this route may be public for registration)
router.post('/new', newuser);

// Protect the following routes with authentication middleware
router.get('/:id', authMiddleware, getUser);
router.put('/:id', authMiddleware, updateUser);
router.delete('/:id', authMiddleware, deleteUser);

export default router;
</file>

<file path="src/swagger.ts">
const Options={
    definition: {
    openepi:"3.0.0",
    info:{
         title:"Product CRUD REST API",
         version:"1.0.0",
         description:"This is simple CRUD API node with Express and documented with swagger"
    },
     servers: [
        {
        url:"http://localhost:5000",
        description:"Development servers"
     }
    ],
    components:{
         schemaa: {
            Product: {
                type: "object",
                require: ["name","description","price","imageUrl","category"],
                properties: {
                name:{
                    type:"string",
                    description:"The name of product"
                },
               description: {
                type: "string",
                description: "The description of the product"
               },
               price:{

              type: "integer",
               description: "The price of product"
               },
               imageUrl: {
                type: "string",
                description:"The image of product"
               },
               category :{
                type: "string",
                description:"The category of product"
               },
                }
            }
         }
    },
    responses: {
    400: {
        
    }
    }
    }
    }
</file>

<file path="src/tsconfig.json">
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "es2020",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    "rootDir": "./",                                  /* Specify the root folder within your source files. */
    "moduleResolution": "node",                       /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    "outDir": "./dist",                                /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
    // "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    "strict": true,                                      /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
  }
}
</file>

<file path="src/types.ts">
export interface ApiResponse<T = any> {
  success: boolean;
  message: string;
  data?: T;
}
</file>

<file path="src/types/express.d.ts">
import UserModel from '../Models/UserModel';

declare global {
  namespace Express {
    interface Request {
      user?: typeof UserModel extends { new (...args: any[]): infer U } ? U : any;
    }
  }
}
</file>

<file path="src/utils/auth.ts">
import bcrypt from 'bcryptjs';

const saltRounds = 10
export const hashPassword = async (password: string): Promise<string> => {
  const hashedPassword = await bcrypt.hash(password, saltRounds);
  return hashedPassword;
};

// Compare password with hashed password
export const comparePasswords = async (password: string, hashedPassword: string): Promise<boolean> => {
  return bcrypt.compare(password, hashedPassword);
};
</file>

<file path="src/utils/sendEmails.ts">
import nodemailer, { Transporter, SendMailOptions } from "nodemailer";
import dotenv from "dotenv";
dotenv.config();

const transporter: Transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
  tls: {
    rejectUnauthorized: false,
  },
});

const mailerSender = async (
  to: string,
  subject: string,
  htmlContent: string
): Promise<boolean> => {
  try {
    const mailOptions: SendMailOptions = {
      from: process.env.EMAIL_USER,
      to,
      subject,
      html: htmlContent,
    };

    await transporter.sendMail(mailOptions);
    console.log("Email sent successfully");
    return true;
  } catch (error: any) {
    console.error("Error sending email: ", error.message);
    return false;
  }
};

export default mailerSender;
</file>

<file path="ts-server/package.json">
{
  "name": "e-commerce",
  "version": "1.0.0",
  "main": "index.js",
  "dependencies": {
    "accepts": "^2.0.0",
    "acorn": "^8.15.0",
    "acorn-walk": "^8.3.4",
    "anymatch": "^3.1.3",
    "arg": "^4.1.3",
    "balanced-match": "^1.0.2",
    "binary-extensions": "^2.3.0",
    "body-parser": "^2.2.0",
    "brace-expansion": "^1.1.12",
    "braces": "^3.0.3",
    "bson": "^6.10.4",
    "buffer-from": "^1.1.2",
    "bytes": "^3.1.2",
    "call-bind-apply-helpers": "^1.0.2",
    "call-bound": "^1.0.4",
    "chokidar": "^3.6.0",
    "concat-map": "^0.0.1",
    "content-disposition": "^1.0.0",
    "content-type": "^1.0.5",
    "cookie": "^0.7.2",
    "cookie-signature": "^1.2.2",
    "create-require": "^1.1.1",
    "debug": "^4.4.1",
    "depd": "^2.0.0",
    "diff": "^4.0.2",
    "dotenv": "^17.2.2",
    "dunder-proto": "^1.0.1",
    "dynamic-dedupe": "^0.3.0",
    "ee-first": "^1.1.1",
    "encodeurl": "^2.0.0",
    "es-define-property": "^1.0.1",
    "es-errors": "^1.3.0",
    "es-object-atoms": "^1.1.1",
    "escape-html": "^1.0.3",
    "etag": "^1.8.1",
    "express": "^5.1.0",
    "fill-range": "^7.1.1",
    "finalhandler": "^2.1.0",
    "forwarded": "^0.2.0",
    "fresh": "^2.0.0",
    "fs.realpath": "^1.0.0",
    "function-bind": "^1.1.2",
    "get-intrinsic": "^1.3.0",
    "get-proto": "^1.0.1",
    "glob": "^7.2.3",
    "glob-parent": "^5.1.2",
    "gopd": "^1.2.0",
    "has-symbols": "^1.1.0",
    "hasown": "^2.0.2",
    "http-errors": "^2.0.0",
    "iconv-lite": "^0.6.3",
    "inflight": "^1.0.6",
    "inherits": "^2.0.4",
    "ipaddr.js": "^1.9.1",
    "is-binary-path": "^2.1.0",
    "is-core-module": "^2.16.1",
    "is-extglob": "^2.1.1",
    "is-glob": "^4.0.3",
    "is-number": "^7.0.0",
    "is-promise": "^4.0.0",
    "kareem": "^2.6.3",
    "make-error": "^1.3.6",
    "math-intrinsics": "^1.1.0",
    "media-typer": "^1.1.0",
    "memory-pager": "^1.5.0",
    "merge-descriptors": "^2.0.0",
    "mime-db": "^1.54.0",
    "mime-types": "^3.0.1",
    "minimatch": "^3.1.2",
    "minimist": "^1.2.8",
    "mkdirp": "^1.0.4",
    "mongodb": "^6.18.0",
    "mongodb-connection-string-url": "^3.0.2",
    "mongoose": "^8.18.0",
    "mpath": "^0.9.0",
    "mquery": "^5.0.0",
    "ms": "^2.1.3",
    "negotiator": "^1.0.0",
    "normalize-path": "^3.0.0",
    "object-inspect": "^1.13.4",
    "on-finished": "^2.4.1",
    "once": "^1.4.0",
    "parseurl": "^1.3.3",
    "path-is-absolute": "^1.0.1",
    "path-parse": "^1.0.7",
    "path-to-regexp": "^8.3.0",
    "picomatch": "^2.3.1",
    "proxy-addr": "^2.0.7",
    "punycode": "^2.3.1",
    "qs": "^6.14.0",
    "range-parser": "^1.2.1",
    "raw-body": "^3.0.1",
    "readdirp": "^3.6.0",
    "resolve": "^1.22.10",
    "rimraf": "^2.7.1",
    "router": "^2.2.0",
    "safe-buffer": "^5.2.1",
    "safer-buffer": "^2.1.2",
    "send": "^1.2.0",
    "serve-static": "^2.2.0",
    "setprototypeof": "^1.2.0",
    "side-channel": "^1.1.0",
    "side-channel-list": "^1.0.0",
    "side-channel-map": "^1.0.1",
    "side-channel-weakmap": "^1.0.2",
    "sift": "^17.1.3",
    "source-map": "^0.6.1",
    "source-map-support": "^0.5.21",
    "sparse-bitfield": "^3.0.3",
    "statuses": "^2.0.2",
    "strip-bom": "^3.0.0",
    "strip-json-comments": "^2.0.1",
    "supports-preserve-symlinks-flag": "^1.0.0",
    "to-regex-range": "^5.0.1",
    "toidentifier": "^1.0.1",
    "tr46": "^5.1.1",
    "tree-kill": "^1.2.2",
    "ts-node": "^10.9.2",
    "tsconfig": "^7.0.0",
    "type-is": "^2.0.1",
    "undici-types": "^7.10.0",
    "unpipe": "^1.0.0",
    "v8-compile-cache-lib": "^3.0.1",
    "vary": "^1.1.2",
    "webidl-conversions": "^7.0.0",
    "whatwg-url": "^14.2.0",
    "wrappy": "^1.0.2",
    "xtend": "^4.0.2",
    "yn": "^3.1.1"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "keywords": [],
  "devDependencies": {
    "@types/express": "^5.0.3",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^24.3.1",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.9.2"
  },
  "description": ""
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "es2020",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    "rootDir": "./",                                  /* Specify the root folder within your source files. */
    "moduleResolution": "node",                       /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    "outDir": "./dist",                                /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
    // "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    "strict": true,                                      /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
  }
}
</file>

<file path="src/controllers/Productcontroller.ts">
import { Request, Response } from "express";
import cloudinary from "../cloudinaryConfig";
import Product from "../Models/ProductModel";

import multer from 'multer';

const storage = multer.memoryStorage();
const upload = multer({ storage: storage });

export const createProduct = async (req: Request, res: Response) => {
  try {
    const { name, description, price, category } = req.body;
    const image = req.file;
  
    if (!name || !description || !price) {
      return res.status(400).json({
        success: false,
        message: 'Name, description, and price are required',
      });
    }
  
    let imageUrl = null;
    if (image) {
      const cloudinaryResponse = await cloudinary.uploader.upload_stream(
        { resource_type: 'auto' },
        (error: any , result: any ) => {
          if (error) {
            throw new Error('Image upload failed');
          }
          imageUrl = result?.secure_url;
        }
      ); 
    
      image.stream.pipe(cloudinaryResponse);
    }
    const product = await Product.create({
      name,
      description,
      price,
      imageUrl,
      category,
    });

    res.status(201).json({ success: true, data: product });
  } catch (err) {
    res.status(500).json({ success: false, message: 'Server Error' });
  }
};

export const getAllProducts = async (_req: Request, res: Response) => {
  try {
    const products = await Product.find();
    res.status(200).json({ success: true, data: products });
  } catch (err) {
    res.status(500).json({ success: false, message: 'Server Error' });
  }
};

export const getProductById = async (req: Request, res: Response) => {
  try {
    const product = await Product.findById(req.params.id);
    if (!product) {
      return res.status(404).json({ success: false, message: 'Product not found' });
    }
    res.status(200).json({ success: true, data: product });
  } catch (err) {
    res.status(500).json({ success: false, message: 'Server Error' });
  }
};

export const updateProduct = async (req: Request, res: Response) => {
  try {
    const { name, description, price, category } = req.body;
    const image = req.file;
  
    let imageUrl = null;
    if (image) {
      const cloudinaryResponse = await cloudinary.uploader.upload_stream(
        { resource_type: 'auto' },
        (error, result) => {
          if (error) {
            throw new Error('Image upload failed');
          }
          imageUrl = result?.secure_url;
        }
      );
      image.stream.pipe(cloudinaryResponse);
    }
  
    const updated = await Product.findByIdAndUpdate(
      req.params.id,
      { name, description, price, category, imageUrl },
      { new: true }
    );

    if (!updated) {
      return res.status(404).json({ success: false, message: 'Product not found' });
    }

    res.status(200).json({ success: true, data: updated });
  } catch (err) {
    res.status(500).json({ success: false, message: 'Server Error' });
  }
};

export const deleteProduct = async (req: Request, res: Response) => {
  try {
    const deleted = await Product.findByIdAndDelete(req.params.id);
    if (!deleted) {
      return res.status(404).json({ success: false, message: 'Product not found' });
    }
    res.status(200).json({ success: true, message: 'Product deleted' });
  } catch (err) {
    res.status(500).json({ success: false, message: 'Server Error' });
  }
};
</file>

<file path="src/controllers/Usercontroller.ts">
import { Request, Response } from 'express';
import UserModel from '../Models/UserModel';

export interface User {
  name: string;
  email: string;
  password: string;
}

// Create a new user
export const newuser = async (req: Request, res: Response): Promise<void> => {
  try {
    const { name, email, password }: User = req.body; // Using the User interface
    const newUser = await UserModel.create({ name, email, password });
    res.status(201).json(newUser);
  } catch (error) {
    res.status(500).json({ message: 'Failed to create user', error });
  }
};

export const getAllUsers = async (req: Request, res: Response) => {
  try {
    const users = await UserModel.find();
    res.status(200).json({ success: true, data: users });
  } catch (err: any) {
    res.status(500).json({ success: false, message: err.message });
  }
};


// Get a user by ID
export const getUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const userId = req.params.id;
    const user = await UserModel.findById(userId);
    if (!user) {
      res.status(404).json({ message: 'User not found' });
    } else {
      res.status(200).json(user);
    }
  } catch (error) {
    res.status(500).json({ message: 'Failed to get user', error });
  }
};

// Update a user by ID
export const updateUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const updatedUser: User = req.body; 
    const user = await UserModel.findByIdAndUpdate(req.params.id, updatedUser, { new: true });
    if (!user) {
      res.status(404).json({ message: 'User not found' });
    } else {
      res.status(200).json(user);
    }
  } catch (error) {
    res.status(500).json({ message: 'Failed to update user', error });
  }
};

// Delete a user by ID
export const deleteUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const user = await UserModel.findByIdAndDelete(req.params.id);
    if (!user) {
      res.status(404).json({ message: 'User not found' });
    } else {
      res.status(200).json({ message: 'User deleted successfully' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Failed to delete user', error });
  }
};
</file>

<file path="src/Routes/AuthRoutes.ts">
import express from 'express';
import { loginUser, registerUser,forgotPassword,resetPassword } from '../controllers/Authcontrollers'
import { getAllUsers } from "../controllers/Usercontroller";
import { authMiddleware } from '../middlewares/Authmiddlewares';

const router = express.Router();

// Public routes
router.post('/register', registerUser);
router.post('/login', loginUser);

router.get("/", authMiddleware, getAllUsers);

router.post('/forgot-password', forgotPassword)
router.post('/reset-password', resetPassword);

// Example protected route that requires a valid token
router.get('/profile', authMiddleware, (req, res) => {
  res.status(200).json({ message: 'You accessed a protected route!', user: req.user });
});

export default router;
</file>

<file path="src/utils/jwt.ts">
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';

dotenv.config();

const { JWT_SECRET } = process.env;

if (!JWT_SECRET) {
  throw new Error('JWT_SECRET is not defined in your environment variables.');
}
export const generateToken = (_id: string): string => {
  return jwt.sign(
    { _id },
    JWT_SECRET,
    { expiresIn: '1h' }
  );
};

export const verifyToken = (token: string): any => {
  try {
    return jwt.verify(token, JWT_SECRET as string); 
  } catch (error) {
    return null;
  }
};
</file>

<file path="src/controllers/Authcontrollers.ts">
import { Request, Response } from 'express';
import { hashPassword, comparePasswords } from '../utils/auth';
import { generateToken } from '../utils/jwt';
import UserModel from '../Models/UserModel';
import mailerSender from '../utils/sendEmails'; // your email utility

export interface User {
  name: string;
  email: string;
  password: string;
  role: string;
}

/**
 * LOGIN USER
 */
export const loginUser = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { email, password }: { email: string, password: string, role: string } = req.body;

    const user = await UserModel.findOne({ email });

    if (!user) {
      return res.status(400).json({ message: 'Invalid email or password' });
    }

    const isMatch = await comparePasswords(password, user.password);

    if (!isMatch) {
      return res.status(400).json({ message: 'Invalid email or password' });
    }

    const token = generateToken(user._id.toString()); 

    return res.status(200).json({
      message: 'Login successful',
      role: user.role,
      token, 
    });
  } catch (error) {
    return res.status(500).json({ message: 'Login failed', error });
  }
};

/**
 * REGISTER USER
 */
export const registerUser = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { name, email, password, role }: { name: string, email: string, password: string, role: string } = req.body;

    // Check if user already exists
    const existingUser = await UserModel.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'User already exists' });
    }

    const hashedPassword = await hashPassword(password);

    const newUser = new UserModel({
      name,
      email,
      password: hashedPassword,
      role,
    });

    await newUser.save();

    const token = generateToken(newUser._id.toString());

    return res.status(201).json({
      message: 'Registration successful',
      role: newUser.role,
      token,
    });
  } catch (error) {
    return res.status(500).json({ message: 'Registration failed', error });
  }
};

/**
 * FORGOT PASSWORD - send OTP to email
 */
const generateOtp = () => Math.floor(100000 + Math.random() * 900000).toString();

export const forgotPassword = async (req: Request, res: Response) => {
  try {
    const { email } = req.body;
    const user = await UserModel.findOne({ email });

    if (!user) return res.status(404).json({ message: "User not found" });

    const otp = generateOtp();
    user.otp = otp;
    user.otpExpiresAt = new Date(Date.now() + 5 * 60 * 1000); // 5 min
    await user.save();

    // Send OTP email
    const htmlContent = `
      <h3>Password Reset Request</h3>
      <p>Your OTP to reset your password is:</p>
      <h2>${otp}</h2>
      <p>This OTP is valid for 5 minutes.</p>
    `;

    await mailerSender(email, "Your Password Reset OTP", htmlContent);

    res.json({ message: "OTP sent to your email." });
  } catch (err: any) {
    console.error("Forgot password error:", err);
    res.status(500).json({ message: "Server error" });
  }
};

/**
 * RESET PASSWORD - verify OTP and set new password
 */
export const resetPassword = async (req: Request, res: Response) => {
  try {
    const { email, otp, newPassword } = req.body;

    const user = await UserModel.findOne({ email });

    if (!user) return res.status(404).json({ message: "User not found" });

    if (!user.otp || user.otp !== otp || !user.otpExpiresAt || user.otpExpiresAt < new Date()) {
      return res.status(400).json({ message: "Invalid or expired OTP" });
    }

    const hashedPassword = await hashPassword(newPassword);

    user.password = hashedPassword;
    user.otp = null;
    user.otpExpiresAt = null;
    await user.save();

    res.json({ message: "Password reset successful!" });
  } catch (err: any) {
    console.error("Reset password error:", err);
    res.status(500).json({ message: "Server error" });
  }
};
</file>

<file path="src/controllers/CartItemcontroller.ts">
import express,{ Request, Response } from "express";
import CartItem from "../Models/CartItemModel";
import Product from "../Models/ProductModel";
import mongoose from "mongoose";

interface CartItemInput {
  productId: string;
  quantity: number;
}
export interface AuthRequest extends Request {
  user?: {
    _id: string;
  };
}

const isValidObjectId = (id: string): boolean => mongoose.Types.ObjectId.isValid(id);

// ➕ Add to Cart
export const addToCart = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?._id;
    const { items } = req.body; // Now this will handle both single and multiple items

    if (!userId) return res.status(401).json({ success: false, message: "Unauthorized" });
    
    // If items is not an array, treat it as a single item
    const cartItems = Array.isArray(items) ? items : [items];

    const cartItemsToAdd = [];

    for (let item of cartItems) {
      const { productId, quantity }: CartItemInput = item;

      if (!isValidObjectId(productId)) {
        return res.status(400).json({ success: false, message: `Invalid productId: ${productId}` });
      }
      if (!Number.isInteger(quantity) || quantity <= 0) {
        return res.status(400).json({ success: false, message: "Quantity must be a positive integer" });
      }

      const product = await Product.findById(productId);
      if (!product) return res.status(404).json({ success: false, message: `Product ${productId} not found` });

      // Check if item already exists in user's cart
      const existingItem = await CartItem.findOne({ userId, productId });

      if (existingItem) {
        existingItem.quantity += quantity;
        await existingItem.save();
        cartItemsToAdd.push(existingItem);
      } else {
        const newCartItem = new CartItem({ userId, productId, quantity });
        await newCartItem.save();
        cartItemsToAdd.push(newCartItem);
      }
    }

    return res.status(200).json({ success: true, message: "Items added to cart", data: cartItemsToAdd });
  } catch (error: any) {
    return res.status(500).json({ success: false, message: error.message });
  }
};


// 📥 Get Cart Items for Authenticated User
export const getCartItems = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?._id;
    if (!userId) return res.status(401).json({ success: false, message: "Unauthorized" });

    const items = await CartItem.find({ userId }).populate("productId");
    return res.status(200).json({ success: true, data: items });
  } catch (error: any) {
    return res.status(500).json({ success: false, message: error.message });
  }
};

// ✏️ Update Quantity of a Cart Item
export const updateCartItem = async (
  req: AuthRequest,
  res: Response
) => {
  try {
    const userId = req.user?._id;
    const { productId } = req.params;
    const { quantity } = req.body;

    if (!userId) return res.status(401).json({ success: false, message: "Unauthorized" });
    if (!isValidObjectId(productId)) return res.status(400).json({ success: false, message: "Invalid productId" });
    if (!Number.isInteger(quantity) || quantity <= 0) return res.status(400).json({ success: false, message: "Quantity must be a positive integer" });

    const item = await CartItem.findOneAndUpdate(
      { userId, productId },
      { quantity },
      { new: true }
    );

    if (!item) return res.status(404).json({ success: false, message: "Cart item not found" });

    return res.status(200).json({ success: true, message: "Cart item updated", data: item });
  } catch (error: any) {
    return res.status(500).json({ success: false, message: error.message });
  }
};

// ❌ Remove Item from Cart
export const removeCartItem = async (
  req: AuthRequest,
  res: Response
) => {
  try {
    const userId = req.user?._id;
    const { cartId } = req.params;

    if (!userId) return res.status(401).json({ success: false, message: "Unauthorized" });
    if (!isValidObjectId(cartId)) return res.status(400).json({ success: false, message: "Invalid cartId" });

    // Fix: Use _id instead of cartId
    const deletedItem = await CartItem.findOneAndDelete({ userId, _id: cartId });

    if (!deletedItem) return res.status(404).json({ success: false, message: "Cart item not found" });

    return res.status(200).json({ success: true, message: "Cart item removed", data: deletedItem });
  } catch (error: any) {
    return res.status(500).json({ success: false, message: error.message });
  }
};
</file>

<file path="src/controllers/Ordercontroller.ts">
import { Request, Response } from "express";
import mongoose from "mongoose";
import CartItem from "../Models/CartItemModel";
import Order from "../Models/OrderModel";
import { IProduct } from "../Models/ProductModel";

// Extend Request to include user
export interface AuthRequest extends Request {
  user?: {
    _id: string;
    role?: string;
  };
}

// 🛒 Place an Order from Cart Items
export const placeOrder = async (req: AuthRequest, res: Response): Promise<any> => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({ success: false, message: "User not authenticated" });
    }

    const cartItemsData = await CartItem.find({ userId }).populate("productId");
    if (!cartItemsData || cartItemsData.length === 0) {
      return res.status(400).json({ success: false, message: "No cart items found for this user" });
    }

    let totalPrice = 0;
    const orderItems: {
      productId: mongoose.Types.ObjectId;
      quantity: number;
      priceAtPurchase: number;
    }[] = [];

    for (const cartItem of cartItemsData) {
      const product = cartItem.productId as unknown as IProduct;
      if (!product) {
        return res.status(404).json({ success: false, message: `Product not found for cart item ${cartItem._id}` });
      }
      const priceAtPurchase = product.price;
      totalPrice += priceAtPurchase * cartItem.quantity;

      orderItems.push({
        productId: product as unknown as mongoose.Types.ObjectId,
        quantity: cartItem.quantity,
        priceAtPurchase,
      });
    }

    const createdOrder = await Order.create({
      userId,
      items: orderItems,
      totalPrice,
      status: "pending",
      createdAt: new Date(),
    });

    // Remove cart items after order creation
    const cartItemIds = cartItemsData.map((cartItem) => cartItem._id);
    await CartItem.deleteMany({ _id: { $in: cartItemIds } });

    return res.status(201).json({
      success: true,
      message: "Order placed successfully",
      data: createdOrder,
    });
  } catch (err: any) {
    console.error("Error during order creation:", err);
    return res.status(500).json({ success: false, message: err?.message || "Internal server error" });
  }
};

// 📦 Get All Orders (Admin sees all, user sees own)
export const getAllOrders = async (req: AuthRequest, res: Response) => {
  try {
    let orders;

    if (req.user?.role === "admin") {
      // Admin sees all orders
      orders = await Order.find()
        .populate("userId", "name email")
        .populate("items.productId", "name price");
    } else {
      // Regular user sees only their own orders
      orders = await Order.find({ userId: req.user?._id })
        .populate("userId", "name email")
        .populate("items.productId", "name price");
    }

    return res.status(200).json({ success: true, data: orders });
  } catch (err: any) {
    return res.status(500).json({ success: false, message: err.message || "Failed to fetch orders", data: null });
  }
};

// 📦 Get a Single Order by ID (only if it belongs to the user or admin)
export const getOrderById = async (req: AuthRequest, res: Response) => {
  try {
    const orderId = req.params.id;
    let order;

    if (req.user?.role === "admin") {
      order = await Order.findById(orderId).populate("items.productId", "name price").populate("userId", "name email");
    } else {
      order = await Order.findOne({ _id: orderId, userId: req.user?._id }).populate("items.productId", "name price");
    }

    if (!order) {
      return res.status(404).json({ success: false, message: "Order not found", data: null });
    }

    return res.status(200).json({ success: true, data: order });
  } catch (err: any) {
    return res.status(500).json({ success: false, message: err.message || "Failed to fetch order", data: null });
  }
};

// ❌ Cancel an Order (only if it belongs to the user)
export const cancelOrder = async (req: AuthRequest, res: Response) => {
  try {
    const orderId = req.params.id;
    let order;

    if (req.user?.role === "admin") {
      order = await Order.findByIdAndDelete(orderId);
    } else {
      order = await Order.findOneAndDelete({ _id: orderId, userId: req.user?._id });
    }

    if (!order) {
      return res.status(404).json({ success: false, message: "Order not found", data: null });
    }

    return res.status(200).json({ success: true, message: "Order canceled", data: order });
  } catch (err: any) {
    return res.status(500).json({ success: false, message: err.message || "Failed to cancel order", data: null });
  }
};
</file>

<file path="src/middlewares/Authmiddlewares.ts">
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import UserModel from '../Models/UserModel';
import dotenv from 'dotenv';
dotenv.config();



const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET) {
  throw new Error('JWT_SECRET is not defined in your environment variables');
}


declare global {
  namespace Express {
    interface Request {
      user?: {
        _id: string;
        email?: string;
        name?: string;
       
      };
    }
  }
}


export const authMiddleware = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authHeader = req.header('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      res.status(401).json({ message: 'Authentication token is missing or invalid format' });
      return;
    }

    const token = authHeader.split(' ')[1]; // "Bearer TOKEN"

    const decoded = jwt.verify(token, JWT_SECRET) as { _id: string };
    const user = await UserModel.findById(decoded._id).select('_id email name'); // or select more if needed

    if (!user) {
      res.status(401).json({ message: 'User not found' });
      return;
    }

    // Attach minimal user info to request (avoid attaching full doc)
    req.user = {
      _id: user._id.toString(),
      email: user.email,
      name: user.name,
    };

    next();
  }
    catch (error: any) {
      console.error("Auth error:", error.message); 
      if (error.name === 'TokenExpiredError') {
        res.status(401).json({ message: 'Token has expired' });
      } else {
        res.status(401).json({ message: 'Invalid or expired token' });
      }
    }

};
</file>

<file path="src/Models/CartItemModel.ts">
import mongoose, { Schema, Document } from "mongoose";

export interface ICartItem extends Document {
  userId: mongoose.Types.ObjectId;
  productId: mongoose.Types.ObjectId;
  quantity: number;
}

const cartItemSchema = new Schema<ICartItem>(
  {
    userId: {
      type: Schema.Types.ObjectId,
      ref: "User", // Referring to the User model
      required: true,
      index: true,  // Adding an index for faster user-based queries
    },
    productId: {
      type: Schema.Types.ObjectId,
      ref: "Product", // Referring to the Product model
      required: true,
      index: true,  // Adding an index for faster product-based queries
    },
    quantity: {
      type: Number,
      required: true,
      min: [1, "Quantity must be at least 1"], // Validating quantity
      max: [100, "Quantity cannot exceed 100"], // Optional: limit for max quantity
    },
  },
  { timestamps: true }
);

export default mongoose.model<ICartItem>("CartItem", cartItemSchema);
</file>

<file path="src/Models/OrderModel.ts">
import mongoose, { Schema, Document } from "mongoose";
import { IProduct } from "./ProductModel";


interface IOrderItem {
  productId: mongoose.Types.ObjectId; // Ref to Product
  quantity: number;
  priceAtPurchase: number;
}

export interface IOrder extends Document {
  userId: mongoose.Types.ObjectId; // Who placed the order
  items: IOrderItem[];
  totalPrice: number; // This should match the sum of item prices
  status: "pending" | "completed" | "canceled"; // Status of the order
  createdAt: Date;
  updatedAt: Date;
}

// Define schema for order items
const OrderItemSchema = new Schema<IOrderItem>({
  productId: { 
    type: Schema.Types.ObjectId, 
    ref: "Product", 
    required: true 
  },
  quantity: { 
    type: Number, 
    required: true 
  },
  priceAtPurchase: { 
    type: Number, 
    required: true 
  },
});

// Define the main Order schema
const OrderSchema = new Schema<IOrder>(
  {
    userId: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    items: {
      type: [OrderItemSchema],
      required: true,
    },
    totalPrice: {
      type: Number,
      required: true,
      validate: {
        // Validation to make sure the total price matches the sum of individual item prices
        validator(value: number) {
          const calculatedTotal = this.items.reduce((acc, item) => acc + (item.priceAtPurchase * item.quantity), 0);
          return value === calculatedTotal;
        },
        message: "Total price does not match the sum of item prices.",
      },
    },
    status: {
      type: String,
      enum: ["pending", "completed", "canceled"],
      default: "pending",
    },
  },
  { timestamps: true }
);

// Automatically populate product details when fetching orders (in mongoose queries)
OrderSchema.pre("findOne", function(next) {
  this.populate('items.productId');  // Populate productId for each order item
  next();
});

OrderSchema.pre("find", function(next) {
  this.populate('items.productId');  // Populate productId for each order item
  next();
});

export default mongoose.model<IOrder>("Order", OrderSchema);
</file>

<file path="src/Models/UserModel.ts">
import { Schema, model, Document, Types } from 'mongoose';

export interface User {
  name: string;
  email: string;
  password: string;
  role: string;
  otp?: string | null;            
  newPassword?: string | null;   
  otpExpiresAt?: Date | null;
}

// Extend Document to include Mongoose document features like _id
interface UserDocument extends User, Document {
  _id: Types.ObjectId; 
}

const userSchema = new Schema<UserDocument>({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  role: { type: String, required: true },

  // OTP and reset fields
  otp: { type: String, default: null },
  newPassword: { type: String, default: null },
  otpExpiresAt: { type: Date, default: null }
}, { timestamps: true });

const UserModel = model<UserDocument>('User', userSchema);

export default UserModel;
</file>

<file path="src/Routes/CartItemRoutes.ts">
import express from "express";
import {
  addToCart,
  getCartItems,
  updateCartItem,
  removeCartItem,
} from "../controllers/CartItemcontroller";
import { authMiddleware } from '../middlewares/Authmiddlewares';

const router = express.Router();

router.post('/', authMiddleware, addToCart);
router.get('/', authMiddleware, getCartItems);
router.put('/:productId', authMiddleware, updateCartItem);
router.delete('/:cartId', authMiddleware, removeCartItem);

export default router;
</file>

<file path="src/Routes/OrderRoutes.ts">
import { Router } from "express";
import { placeOrder, getAllOrders, getOrderById, cancelOrder } from "../controllers/Ordercontroller";
import { authMiddleware } from "../middlewares/Authmiddlewares";
import { io } from "../index"; // ✅ Make sure index.ts exports io

const router = Router();

// Place Order & Emit via Socket.IO
router.post("/", authMiddleware, async (req, res) => {
  try {
    const createdOrder = await placeOrder(req, res);
    if (createdOrder) {
      io.emit("newOrder", createdOrder); // ✅ notify admins
    }
  } catch (err) {
    console.error(err);
    if (!res.headersSent) {
      res.status(500).json({ success: false, message: "Failed to place order" });
    }
  }
});

router.get("/", authMiddleware, getAllOrders);
router.get("/:id", authMiddleware, getOrderById);
router.delete("/:id", authMiddleware, cancelOrder);

export default router;
</file>

<file path="src/Routes/ProductRoutes.ts">
import express from 'express';
import {
  createProduct,
  getAllProducts,
  getProductById,
  updateProduct,
  deleteProduct,
} from "../controllers/Productcontroller";
import { authMiddleware } from '../middlewares/Authmiddlewares';

const router = express.Router();

router.post('/', authMiddleware, createProduct);
router.get('/', authMiddleware, getAllProducts);
router.get('/:id', authMiddleware, getProductById);
router.put('/:id', authMiddleware, updateProduct);
router.delete('/:id', authMiddleware, deleteProduct);

export default router;
</file>

<file path="src/index.ts">
import express from "express";
import { Request, Response } from "express";
import mongoose from "mongoose";
import productRoutes from "./Routes/ProductRoutes";
import orderRoutes from "./Routes/OrderRoutes";
import cartitemRoutes from "./Routes/CartItemRoutes";
import authRoutes from "./Routes/AuthRoutes";
import contactRoutes from "./Routes/ContactRoutes";
import dotenv from "dotenv";
import morgan from "morgan";
import cors from "cors";
import { createServer } from "http";
import { Server } from "socket.io";

dotenv.config();

const app = express();
const server = createServer(app);

// ✅ create io instance
export const io = new Server(server, {
  cors: {
    origin: "http://localhost:5173",
    methods: ["GET", "POST"],
    credentials: true,
  },
});

io.on("connection", (socket) => {
  console.log("New client connected:", socket.id);

  socket.on("disconnect", () => {
    console.log("Client disconnected:", socket.id);
  });
});

app.use(morgan("dev"));
const PORT = process.env.PORT || 5000;

app.use(
  cors({
    origin: "http://localhost:5173",
    credentials: true,
  })
);

app.use(express.json());

app.use("/api/products", productRoutes);
app.use("/api/order", orderRoutes);
app.use("/api/cart", cartitemRoutes);
app.use("/api/auth", authRoutes);
app.use("/api/contact", contactRoutes);

app.get("/", (req: Request, res: Response) => {
  res.json({ message: "Byakunze we", status: "200" });
});

mongoose
  .connect(process.env.DB_URL || "", {})
  .then(() => {
    console.log("MongoDB connected");
    server.listen(PORT, () => {
      console.log(`Server running on http://localhost:${PORT}`);
    });
  })
  .catch((err: any) => console.error("MongoDB connection error:", err));
</file>

<file path="package.json">
{
  "name": "e-commerce",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "dependencies": {
    "@types/nodemailer": "^7.0.1",
    "bcryptjs": "^3.0.2",
    "cloudinary": "^2.7.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.2",
    "jsonwebtoken": "^9.0.2",
    "multer": "^2.0.2",
    "nodemailer": "^7.0.6",
    "socket.io": "^4.8.1",
    "typescript": "^5.9.2",
    "undici-types": "^7.10.0"
  },
  "devDependencies": {
    "@types/cors": "^2.8.19",
    "@types/dotenv": "^6.1.1",
    "@types/express": "^5.0.3",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/mongoose": "^5.11.97",
    "@types/morgan": "^1.9.10",
    "@types/multer": "^2.0.0",
    "express": "^5.1.0",
    "morgan": "^1.10.1",
    "ts-node-dev": "^2.0.0"
  },
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc",
    "start": "node dist/app.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
</file>

</files>
